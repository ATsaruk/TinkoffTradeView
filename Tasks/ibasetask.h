/* Паттерн компановщик, это класс Component, а класс Composite это CustomCommand
 * Тут есть одна заморочка с потоками, по задумке каждая задача должна выполнятся в отдельном потоке, но задача
 * может состоять из нескольких других задач, а те в свою очереь так же из подзадач и появляются проблемы с удалением
 * вложенных потоков... Поэтому введен taskThread, поток формируется в корневой задаче, а остальные задачи переносятся
 * в этот поток, задачу, которая будет корневой назначает TaskManager. Это тонкости реализации при реализации своих
 * задач/комманд об этом можно не заморачиваться, все реализовано в базовых классах.
 *
 * По поводу используемых понятий:
 * Задача - это наследник от IBaseTask, задача выполняет некое 1 действие
 * Комманда - это наследник или эксземпляр IBaseCommand, комманда состоит из задач и/или других комманд,
 *   но т.к. IBaseCommand в свою очередь так же является наследником от IBaseTask, то далее говоря "задача":
 *   речь может идти как о задаче (IBaseTask), так и о комманде (IBaseCommand).
 *
 * Введем понятие:
 *   Корневая задача (RootTask) - это задача(комманда), которая будет передана на исполнение TaskManager'у (класс Manager).
 * Корневой может быть как задача так и комманда (IBaseCommand и её производные),
 * bool isRootTask - признак того что это корневая задача(комманда), этот признак присваивается в функции setThread,
 * в зависимотси от значения родительского потока (QThread *parent):
 *   * если передана ссылка на родительский поток, то:
 *     - ссылка на поток будет сохранена в taskThread = parent и текущий объект будет перенесон в поток parent
 *     - в функции start() будет вызван виртуальный метод exec(), который должен быть реализован в объектах наследниках, это
 *       основной метод, в котором и должны производиться действия, заложенные в задачу/комманду
 *
 *   * если в функцию передан nullptr - это означает что это корневая задача(комманда), и значит для данной задачи(комманды):
 *     - будет создан новый QThread (taskThread), и задача будет переперенесена в этот новый поток.
 *       И если эта комманда, то задачи/комманды, которые будут добавлятся так же будут перенесены в созданный поток taskThread,
 *       при создании новых задач/комманд для данной команды в конструктор будет передаваться taskThread.
 *     - в функции start() произведет запуск потока taskThread->start(),
 *
 * При наследовании от данного класса необходимо в конструкторе передать имя задачи в базовый класс IBaseTask, так же
 * в конструктор можно передать настройки или какие то данные, которые известны перед запуском задачи и не зависят от
 * возможного результата выполнения другиех задач, напримерю ключ акции:
 *   1. Создать коструктор, в котором :
 *     class MyTask : public IBaseTask
 *     {
 *       Data::StockKey key;
 *     public:
 *       MyTask::MyTask(const Data::StockKey &stockKey)
 *              : IBaseTask("MyTaskName"), key(stockKey) {
 *       }
 *     };
 *
 *   при создании:
 *     auto *newTask = new MyTask (stockKey);
 *   будет создана корневая задача, которую можно запустить через TaskManager:
 *     TaskManager->registerTask(newTask);
 *
 *   а так же при добавлении задачи в CustomCommand, функцией addTask, в конструкторе ей будет передаваться указатель на поток,
 *   в котором она будет выполняться.
 *
 *   2. Если нужны входные параметры, то определить функцию void setData(type var)
 *   в неё будут переданы данные при добавлении задачи функцией addTask, например мы хотим передать диапазон дат:
 *     InterfaceWrapper<Data::Range> range;
 *     TaskManager::get()->addTask <MyTask, SharedInterface, Data::StockKey> (var1, var2);
 *   или с учетом С++14:
 *     TaskManager::get()->addTask <MyTask> (range, stockKey);
 *   типы будут выведены автоматически,
 *
 *   Первый аргумент предназначен для функции setData, остальные аргументы будут переданы в конструктор!
 *   Если дополнительных данных передовать не требуется, то НУЖНО объявить функцию setData без аргументов и с пустым телом
 *
 *   Например в качестве исходнных данных у нас будет интервал Data::Range
 *     class MyTask : public IBaseTask
 *     {
 *       InterfaceWrapper<Data::Range> range;
 *     public:
 *       void setData(SharedInterface &interface) override {
 *         range = interface;
 *       }
 *     };
 *
 *   3. Переопределить функцию void exec(), при выполнении нужно следить за флагом isStopRequested, если флаг = true
 *      завершаем выполнение, функция exec() будет вызвана при запуске задачи:
 *     class MyTask : public IBaseTask
 *     {
 *     public:
 *       void MyTask::exec() override
 *       {
 *         //выполнить необходимые действия
 *         for(auto &it : someContainer) {
 *           someAction(it);
 *           ...
 *     ->    if (isStopRequested) {
 *             emit finished();
 *             return;
 *           }
 *         }
 *
 *         saveSomeData();
 *
 *         ...
 *
 *         //по завершению задачи отправить сигнал о завершении
 *         emit finished();
 *       }
 *     }
 *
 *   Задача считаться запущенной пока она не отправит сигнал finished()!
 *
 *   4. Переопределить функцию getResult(), в которой вернуть SharedInterface на результат.
 *     Например результатом будет сформированная акция:
 *     class MyTask : public IBaseTask
 *     {
 *       InterfaceWrapper<Data::Stock> stock;
 *     public:
 *       SharedInterface &getResult() override {
 *         return &stock;
 *       }
 *     };
 *
 *   Задача не обязана выполнятся в методе exec() и быть завершена при выходе из метода exec(), задача может завершится
 *   в другой функции, которая например может быть вызвана по таймеру, или по какому либо другому сигналу или событию. */

#ifndef IBASETASK_H
#define IBASETASK_H

#include "ifunction.h"

namespace Task {


/** @ingroup Task
  * @brief Базовый класс для задачи (паттерн компоновщик) */
class IBaseTask : public IFunction
{
    Q_OBJECT

public:
    explicit IBaseTask(QString taskname);
    virtual ~IBaseTask();

    ///Возвращает поток, в котором находится данный экземпляр класса
    virtual QThread* getThread() final;

    ///Устанавливает поток, в котором будет выполняться задача
    virtual void setThread(QThread *parent) final;

public slots:
    ///Запускает выполнение задачи
    virtual void start() final;

    ///Устанавливает флаг, о необходимости остановки задачи
    virtual void stop();

signals:
    ///Сигнал о завершении работы задачи
    void finished();

protected:
    ///Производит нужные вычисления/операции, будет вызвана при запуске потока (QThread)
    void exec() override = 0;

protected:
    //Поток в котором будет выполняться данная задача
    QThread *taskThread;

private:
    //Признак того, что это корневая задача, она управляет выделением памяти, запуском, остановкой и удалением taskThread
    bool isRootTask;
};

}

#endif // IBASETASK_H
